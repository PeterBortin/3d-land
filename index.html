<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital Organism Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #000;
            overflow: hidden;
            font-family: monospace;
            color: #0f0;
        }
        #console {
            position: absolute;
            top: 5px;
            width: 90%;
            height: auto;
            padding: 2px;
            font-size: 12px;
            line-height: 1;
            overflow: hidden;
            text-align: left;
            background: transparent;
            border: none;
        }
        #modeToggle {
            position: absolute;
            top: 50px;
            width: 90%;
            padding: 2px;
            font-size: 12px;
            text-align: left;
            display: flex;
            align-items: center;
        }
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
            margin-right: 10px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 20px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: #0f0;
        }
        input:checked + .slider:before {
            transform: translateX(20px);
        }
        canvas {
            width: 90vw;
            height: 80vh;
            image-rendering: pixelated;
            border: 2px solid #0f0;
            background-color: #111;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="console"></div>
    <div id="modeToggle">
        <label class="switch">
            <input type="checkbox" id="toggle">
            <span class="slider"></span>
        </label>
        <span id="modeLabel">Пища для организмов</span>
    </div>
    <canvas id="simulationCanvas" width="100" height="150"></canvas>
    <script>
        const canvas = document.getElementById('simulationCanvas');
        const ctx = canvas.getContext('2d');
        const consoleDiv = document.getElementById('console');
        const toggle = document.getElementById('toggle');
        const modeLabel = document.getElementById('modeLabel');

        // Simulation parameters
        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;
        const INITIAL_ORGANISMS = 1;
        const INITIAL_FOOD = 0;
        const MAX_ENERGY = 200;
        const MIN_ENERGY_TO_LAY_EGG = 150;
        const ENERGY_LOSS_PER_FRAME = 0.01;
        const FOOD_ENERGY = 20;
        const CORPSE_ENERGY_GAIN = 60;
        const PARASITE_ENERGY_GAIN = 80;
        const PREDATION_ENERGY_GAIN = 40;
        const VISION_RANGE = 12;
        const COLLISION_DIST = 3;
        const WALL_AVOID_DIST = 5;
        const EGG_HATCH_FRAMES = 180;
        const PARASITE_SPAWN_CHANCE = 0.2;
        const MAX_CORPSES = 100;
        const MIN_FOOD_SPACING = 2;
        const BACTERIUM_SPAWN_INTERVAL = 600; // Every 10 seconds at 60 FPS
        const INFECTION_DURATION = 1800; // 30 seconds at 60 FPS
        const BACTERIUM_SPEED = 0.05;
        const BACTERIUM_SIZE_WIDTH = 2;
        const BACTERIUM_SIZE_HEIGHT = 1.5;
        const CANNIBALISM_THRESHOLD = 100; // Threshold for infected organisms to trigger cannibalism

        let organisms = [];
        let eggs = [];
        let foodParticles = [];
        let corpses = [];
        let bacteria = [];
        let barriers = [];
        let isDrawing = false;
        let lastFoodX = -1;
        let lastFoodY = -1;
        let frameCount = 0;
        let consoleMessages = [];
        let isRunning = true;
        let isCannibalismMode = false;
        let infectedCount = 0;
        let drawMode = 'food';

        toggle.addEventListener('change', () => {
            drawMode = toggle.checked ? 'barrier' : 'food';
            modeLabel.textContent = toggle.checked ? 'Заграждения' : 'Пища для организмов';
        });

        function shortestAngleDiff(from, to) {
            let diff = (to - from) % (2 * Math.PI);
            if (diff > Math.PI) diff -= 2 * Math.PI;
            if (diff < -Math.PI) diff += 2 * Math.PI;
            return diff;
        }

        class Organism {
            constructor(x, y, energy = 50, segmentCount = 5, type = 'green') {
                this.energy = energy;
                this.segmentCount = segmentCount;
                this.angle = Math.random() * 2 * Math.PI;
                this.speed = 0.025 + (energy / MAX_ENERGY) * 0.075;
                this.type = type;
                this.isDead = false;
                this.infected = false;
                this.infectionTimer = 0;
                this.segments = [];
                for (let i = 0; i < this.segmentCount; i++) {
                    this.segments.push({
                        x: x - Math.cos(this.angle) * i * 1.5,
                        y: y - Math.sin(this.angle) * i * 1.5
                    });
                }
                this.updateColor();
            }

            updateColor() {
                try {
                    const t = Math.min(this.energy / MAX_ENERGY, 1);
                    if (this.type === 'red') {
                        const r = Math.floor(85 + 170 * t);
                        const g = Math.floor(85 * (1 - t));
                        const b = Math.floor(85 * (1 - t));
                        this.color = `rgb(${r},${g},${b})`;
                    } else {
                        const r = Math.floor(85 * (1 - t));
                        const g = Math.floor(85 + 170 * t);
                        const b = Math.floor(85 * (1 - t));
                        this.color = `rgb(${r},${g},${b})`;
                    }
                } catch (e) {
                    console.error(`Ошибка в Organism.updateColor: ${e.message}`);
                    addConsoleMessage("Ошибка при обновлении цвета организма");
                }
            }

            update() {
                try {
                    if (this.isDead) {
                        return false;
                    }
                    const head = this.segments[0];

                    // Handle infection
                    if (this.infected) {
                        this.infectionTimer--;
                        if (this.infectionTimer <= 0) {
                            this.isDead = true;
                            if (corpses.length < MAX_CORPSES) {
                                corpses.push(new Corpse(head.x, head.y, CORPSE_ENERGY_GAIN));
                            }
                            addConsoleMessage(`${this.type === 'red' ? 'Красный' : 'Зеленый'} организм умер от инфекции`);
                            return false;
                        }
                    }

                    // Avoid walls
                    let futureX = head.x + Math.cos(this.angle) * this.speed * 10;
                    let futureY = head.y + Math.sin(this.angle) * this.speed * 10;
                    if (futureX < WALL_AVOID_DIST || futureX > WIDTH - WALL_AVOID_DIST ||
                        futureY < WALL_AVOID_DIST || futureY > HEIGHT - WALL_AVOID_DIST) {
                        this.angle += (Math.random() > 0.5 ? 1 : -1) * Math.PI / 2;
                    }

                    // Avoid barriers
                    for (let bar of barriers) {
                        const d = Math.hypot(futureX - bar.x, futureY - bar.y);
                        if (d < WALL_AVOID_DIST) {
                            this.angle += (Math.random() > 0.5 ? 1 : -1) * Math.PI / 2;
                        }
                    }

                    // Intelligence
                    let target = null;
                    if (isCannibalismMode) {
                        let minDist = Infinity;
                        for (let org of organisms) {
                            if (!org || org === this || !org.infected) continue;
                            const d = Math.hypot(org.segments[0].x - head.x, org.segments[0].y - head.y);
                            if (d < VISION_RANGE && d < minDist) {
                                minDist = d;
                                target = org.segments[0];
                            }
                        }
                    }

                    if (!target && this.energy < 50) {
                        let minDist = Infinity;
                        for (let corpse of corpses) {
                            if (!corpse) continue;
                            const d = Math.hypot(corpse.x - head.x, corpse.y - head.y);
                            if (d < VISION_RANGE && d < minDist) {
                                minDist = d;
                                target = {x: corpse.x, y: corpse.y};
                            }
                        }
                    } else if (!target) {
                        let minDist = Infinity;
                        for (let food of foodParticles) {
                            if (!food) continue;
                            const d = Math.hypot(food.x - head.x, food.y - head.y);
                            if (d < VISION_RANGE && d < minDist) {
                                minDist = d;
                                target = {x: food.x, y: food.y};
                            }
                        }
                        for (let bacterium of bacteria) {
                            if (!bacterium) continue;
                            const d = Math.hypot(bacterium.x - head.x, bacterium.y - head.y);
                            if (d < VISION_RANGE && d < minDist) {
                                minDist = d;
                                target = {x: bacterium.x, y: bacterium.y};
                            }
                        }
                    }

                    if (!target && this.type === 'red') {
                        let minEnergy = Infinity;
                        for (let org of organisms) {
                            if (!org || org.isDead || org.type === 'red' || org.energy >= this.energy) continue;
                            const d = Math.hypot(org.segments[0].x - head.x, org.segments[0].y - head.y);
                            if (d < VISION_RANGE && org.energy < minEnergy) {
                                minEnergy = org.energy;
                                target = org.segments[0];
                            }
                        }
                    } else if (!target && this.type === 'green' && this.energy > 75) {
                        let minDist = Infinity;
                        for (let org of organisms) {
                            if (!org || org.isDead || org.type !== 'red') continue;
                            const d = Math.hypot(org.segments[0].x - head.x, org.segments[0].y - head.y);
                            if (d < VISION_RANGE && d < minDist) {
                                minDist = d;
                                target = org.segments[0];
                            }
                        }
                    }

                    if (target) {
                        const targetAngle = Math.atan2(target.y - head.y, target.x - head.x);
                        this.angle += shortestAngleDiff(this.angle, targetAngle) * 0.2;
                    } else if (Math.random() < 0.05) {
                        const randomTurn = (Math.random() - 0.5) * Math.PI / 2;
                        this.angle += shortestAngleDiff(this.angle, this.angle + randomTurn) * 0.2;
                    }

                    // Move head with barrier check
                    const dx = Math.cos(this.angle) * this.speed;
                    const dy = Math.sin(this.angle) * this.speed;
                    let newX = head.x + dx;
                    let newY = head.y + dy;
                    let colliding = false;
                    for (let bar of barriers) {
                        if (Math.hypot(newX - bar.x, newY - bar.y) < COLLISION_DIST) {
                            colliding = true;
                            break;
                        }
                    }
                    if (!colliding) {
                        head.x = newX;
                        head.y = newY;
                    } else {
                        this.angle += Math.PI + (Math.random() - 0.5) * Math.PI / 4;
                    }

                    // Clamp boundaries
                    head.x = Math.max(0, Math.min(WIDTH, head.x));
                    head.y = Math.max(0, Math.min(HEIGHT, head.y));

                    // Move segments
                    for (let i = 1; i < this.segments.length; i++) {
                        const prev = this.segments[i - 1];
                        const curr = this.segments[i];
                        const dx = prev.x - curr.x;
                        const dy = prev.y - curr.y;
                        const dist = Math.hypot(dx, dy);
                        if (dist > 1.5) {
                            curr.x += (dx / dist) * (dist - 1.5);
                            curr.y += (dy / dist) * (dist - 1.5);
                        }
                    }

                    // Lose energy
                    this.energy -= ENERGY_LOSS_PER_FRAME;
                    if (this.energy <= 0) {
                        this.isDead = true;
                        if (corpses.length < MAX_CORPSES) {
                            corpses.push(new Corpse(head.x, head.y, CORPSE_ENERGY_GAIN));
                        }
                        addConsoleMessage(`${this.type === 'red' ? 'Красный' : 'Зеленый'} организм умер от истощения`);
                        return false;
                    }

                    // Adjust segments
                    const idealSegments = Math.max(2, Math.floor(this.energy / 15) + 2);
                    if (idealSegments > this.segmentCount && this.segmentCount < 15) {
                        if (this.segmentCount >= 2) {
                            const tail = this.segments[this.segmentCount - 1];
                            const prevTail = this.segments[this.segmentCount - 2];
                            const dx = tail.x - prevTail.x;
                            const dy = tail.y - prevTail.y;
                            const dist = Math.hypot(dx, dy);
                            const newX = dist > 0 ? tail.x + (dx / dist) * 0.5 : tail.x + 0.5;
                            const newY = dist > 0 ? tail.y + (dy / dist) * 0.5 : tail.y + 0.5;
                            this.segments.push({x: newX, y: newY});
                            this.segmentCount++;
                        }
                    } else if (idealSegments < this.segmentCount) {
                        this.segments.pop();
                        this.segmentCount--;
                    }

                    // Lay egg if overfed
                    if (this.energy > MIN_ENERGY_TO_LAY_EGG && Math.random() < 0.01) {
                        this.layEgg();
                    }

                    // Update speed and color
                    this.speed = 0.025 + (this.energy / MAX_ENERGY) * 0.075;
                    this.updateColor();

                    return true;
                } catch (e) {
                    console.error(`Ошибка в Organism.update: ${e.message}`);
                    addConsoleMessage("Ошибка в обновлении организма");
                    return false;
                }
            }

            layEgg() {
                try {
                    const childEnergy = 20 + Math.random() * 10;
                    if (this.energy - childEnergy < 10) return;
                    this.energy -= childEnergy;
                    const head = this.segments[0];
                    const egg = new Egg(head.x + (Math.random() - 0.5) * 5, head.y + (Math.random() - 0.5) * 5, childEnergy, this.type);
                    if (this.infected) {
                        egg.infected = true;
                    }
                    eggs.push(egg);
                    addConsoleMessage("Яйцо отложено");
                } catch (e) {
                    console.error(`Ошибка в layEgg: ${e.message}`);
                    addConsoleMessage("Ошибка при откладывании яйца");
                }
            }

            eatFood(index) {
                try {
                    this.energy = Math.min(MAX_ENERGY, this.energy + FOOD_ENERGY);
                    foodParticles.splice(index, 1);
                    addConsoleMessage("Еда съедена");
                    if (this.type === 'green' && Math.random() < PARASITE_SPAWN_CHANCE) {
                        organisms.push(new Organism(this.segments[0].x, this.segments[0].y, 50, 5, 'red'));
                        addConsoleMessage("Красный организм появился");
                    }
                    if (this.segmentCount < 15) {
                        const tail = this.segments[this.segmentCount - 1];
                        const prevTail = this.segments[this.segmentCount - 2];
                        const dx = tail.x - prevTail.x;
                        const dy = tail.y - prevTail.y;
                        const dist = Math.hypot(dx, dy);
                        const newX = dist > 0 ? tail.x + (dx / dist) * 0.5 : tail.x + 0.5;
                        const newY = dist > 0 ? tail.y + (dy / dist) * 0.5 : tail.y + 0.5;
                        this.segments.push({x: newX, y: newY});
                        this.segmentCount++;
                        addConsoleMessage("Организм вырос");
                    }
                    this.updateColor();
                } catch (e) {
                    console.error(`Ошибка в eatFood: ${e.message}`);
                    addConsoleMessage("Ошибка при поедании еды");
                }
            }

            eatCorpse(index) {
                try {
                    this.energy = Math.min(MAX_ENERGY, this.energy + corpses[index].energy);
                    const segmentsToAdd = Math.floor(corpses[index].energy / 15);
                    corpses.splice(index, 1);
                    addConsoleMessage("Труп съеден");
                    if (this.type === 'green' && Math.random() < PARASITE_SPAWN_CHANCE) {
                        organisms.push(new Organism(this.segments[0].x, this.segments[0].y, 50, 5, 'red'));
                        addConsoleMessage("Красный организм появился");
                    }
                    for (let i = 0; i < segmentsToAdd && this.segmentCount < 15; i++) {
                        const tail = this.segments[this.segmentCount - 1];
                        const prevTail = this.segments[this.segmentCount - 2];
                        const dx = tail.x - prevTail.x;
                        const dy = tail.y - prevTail.y;
                        const dist = Math.hypot(dx, dy);
                        const newX = dist > 0 ? tail.x + (dx / dist) * 0.5 : tail.x + 0.5;
                        const newY = dist > 0 ? tail.y + (dy / dist) * 0.5 : tail.y + 0.5;
                        this.segments.push({x: newX, y: newY});
                        this.segmentCount++;
                        addConsoleMessage("Организм вырос");
                    }
                    this.updateColor();
                } catch (e) {
                    console.error(`Ошибка в eatCorpse: ${e.message}`);
                    addConsoleMessage("Ошибка при поедании трупа");
                }
            }

            eatBacterium(index) {
                try {
                    this.energy = Math.min(MAX_ENERGY, this.energy + FOOD_ENERGY);
                    bacteria.splice(index, 1);
                    this.infected = true;
                    this.infectionTimer = INFECTION_DURATION;
                    addConsoleMessage(`${this.type === 'red' ? 'Красный' : 'Зеленый'} организм заражен бактерией`);
                } catch (e) {
                    console.error(`Ошибка в eatBacterium: ${e.message}`);
                    addConsoleMessage("Ошибка при поедании бактерии");
                }
            }

            eatOrganism(other) {
                try {
                    this.energy = Math.min(MAX_ENERGY, this.energy + (this.type === 'red' ? PARASITE_ENERGY_GAIN : PREDATION_ENERGY_GAIN));
                    if (other.infected && !isCannibalismMode) {
                        this.infected = true;
                        this.infectionTimer = INFECTION_DURATION;
                        addConsoleMessage(`${this.type === 'red' ? 'Красный' : 'Зеленый'} организм заражен от другого`);
                    }
                    other.isDead = true;
                    addConsoleMessage(this.type === 'red' ? "Красный организм поглотил зеленый" : "Зеленый организм поглотил красный");
                    const segmentsToAdd = Math.floor((this.type === 'red' ? PARASITE_ENERGY_GAIN : PREDATION_ENERGY_GAIN) / 15);
                    for (let i = 0; i < segmentsToAdd && this.segmentCount < 15; i++) {
                        const tail = this.segments[this.segmentCount - 1];
                        const prevTail = this.segments[this.segmentCount - 2];
                        const dx = tail.x - prevTail.x;
                        const dy = tail.y - prevTail.y;
                        const dist = Math.hypot(dx, dy);
                        const newX = dist > 0 ? tail.x + (dx / dist) * 0.5 : tail.x + 0.5;
                        const newY = dist > 0 ? tail.y + (dy / dist) * 0.5 : tail.y + 0.5;
                        this.segments.push({x: newX, y: newY});
                        this.segmentCount++;
                        addConsoleMessage("Организм вырос");
                    }
                    this.updateColor();
                } catch (e) {
                    console.error(`Ошибка в eatOrganism: ${e.message}`);
                    addConsoleMessage("Ошибка при поедании организма");
                }
            }

            draw() {
                try {
                    const pulse = Math.sin(Date.now() / 150) * 0.5 + 1.5;
                    ctx.strokeStyle = this.infected && (frameCount % 30 < 15) ? '#f0f' : this.color;
                    ctx.fillStyle = this.infected && (frameCount % 30 < 15) ? '#f0f' : this.color;
                    ctx.beginPath();
                    ctx.arc(this.segments[0].x, this.segments[0].y, 1.5, 0, 2 * Math.PI);
                    ctx.fill();
                    for (let i = 1; i < this.segments.length; i++) {
                        ctx.beginPath();
                        ctx.moveTo(this.segments[i - 1].x, this.segments[i - 1].y);
                        ctx.lineTo(this.segments[i].x, this.segments[i].y);
                        ctx.lineWidth = 1 + (this.segments.length - i) / 5 * pulse;
                        ctx.stroke();
                    }
                } catch (e) {
                    console.error(`Ошибка в Organism.draw: ${e.message}`);
                    addConsoleMessage("Ошибка при отрисовке организма");
                }
            }
        }

        class Egg {
            constructor(x, y, energy, type = 'green') {
                this.x = x;
                this.y = y;
                this.energy = energy;
                this.type = type;
                this.age = 0;
                this.infected = false;
            }

            update() {
                try {
                    this.age++;
                    if (this.age >= EGG_HATCH_FRAMES) {
                        const newOrg = new Organism(this.x, this.y, this.energy, 5, this.type);
                        if (this.infected) {
                            newOrg.infected = true;
                            newOrg.infectionTimer = INFECTION_DURATION;
                        }
                        organisms.push(newOrg);
                        addConsoleMessage(this.type === 'red' ? "Красный организм вылупился" : "Зеленый организм вылупился");
                        return false;
                    }
                    return true;
                } catch (e) {
                    console.error(`Ошибка в Egg.update: ${e.message}`);
                    addConsoleMessage("Ошибка в обновлении яйца");
                    return false;
                }
            }

            draw() {
                try {
                    ctx.fillStyle = this.infected ? '#a0a' : this.type === 'red' ? '#800' : '#555';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 1.5, 0, 2 * Math.PI);
                    ctx.fill();
                } catch (e) {
                    console.error(`Ошибка в Egg.draw: ${e.message}`);
                    addConsoleMessage("Ошибка при отрисовке яйца");
                }
            }
        }

        class FoodParticle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            draw() {
                try {
                    ctx.fillStyle = '#ff0';
                    ctx.fillRect(Math.floor(this.x), Math.floor(this.y), 1, 1);
                } catch (e) {
                    console.error(`Ошибка в FoodParticle.draw: ${e.message}`);
                    addConsoleMessage("Ошибка при отрисовке еды");
                }
            }
        }

        class Barrier {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }

            draw() {
                try {
                    ctx.fillStyle = '#888';
                    ctx.fillRect(Math.floor(this.x), Math.floor(this.y), 1, 1);
                } catch (e) {
                    console.error(`Ошибка в Barrier.draw: ${e.message}`);
                    addConsoleMessage("Ошибка при отрисовке заграждения");
                }
            }
        }

        class Corpse {
            constructor(x, y, energy) {
                this.x = x;
                this.y = y;
                this.energy = energy;
            }

            draw() {
                try {
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(Math.floor(this.x), Math.floor(this.y), 1, 1);
                } catch (e) {
                    console.error(`Ошибка в Corpse.draw: ${e.message}`);
                    addConsoleMessage("Ошибка при отрисовке трупа");
                }
            }
        }

        class Bacterium {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.angle = Math.random() * 2 * Math.PI;
                this.speed = BACTERIUM_SPEED;
            }

            update() {
                try {
                    // Avoid walls
                    let futureX = this.x + Math.cos(this.angle) * this.speed * 10;
                    let futureY = this.y + Math.sin(this.angle) * this.speed * 10;
                    if (futureX < WALL_AVOID_DIST || futureX > WIDTH - WALL_AVOID_DIST ||
                        futureY < WALL_AVOID_DIST || futureY > HEIGHT - WALL_AVOID_DIST) {
                        this.angle += (Math.random() > 0.5 ? 1 : -1) * Math.PI / 2;
                    }

                    // Avoid barriers
                    for (let bar of barriers) {
                        const d = Math.hypot(futureX - bar.x, futureY - bar.y);
                        if (d < WALL_AVOID_DIST) {
                            this.angle += (Math.random() > 0.5 ? 1 : -1) * Math.PI / 2;
                        }
                    }

                    // Move with barrier check
                    const dx = Math.cos(this.angle) * this.speed;
                    const dy = Math.sin(this.angle) * this.speed;
                    let newX = this.x + dx;
                    let newY = this.y + dy;
                    let colliding = false;
                    for (let bar of barriers) {
                        if (Math.hypot(newX - bar.x, newY - bar.y) < COLLISION_DIST) {
                            colliding = true;
                            break;
                        }
                    }
                    if (!colliding) {
                        this.x = newX;
                        this.y = newY;
                    } else {
                        this.angle += Math.PI + (Math.random() - 0.5) * Math.PI / 4;
                    }

                    // Clamp boundaries
                    this.x = Math.max(0, Math.min(WIDTH, this.x));
                    this.y = Math.max(0, Math.min(HEIGHT, this.y));

                    // Random curve change
                    if (Math.random() < 0.05) {
                        this.angle += (Math.random() - 0.5) * Math.PI / 2;
                    }

                    return true;
                } catch (e) {
                    console.error(`Ошибка в Bacterium.update: ${e.message}`);
                    addConsoleMessage("Ошибка в обновлении бактерии");
                    return false;
                }
            }

            draw() {
                try {
                    const pulse = Math.sin(Date.now() / 200) * 0.2 + 1;
                    const noiseOffset = Math.sin(Date.now() / 100 + this.x + this.y) * 0.2;
                    ctx.fillStyle = '#00f';
                    ctx.beginPath();
                    ctx.ellipse(this.x + noiseOffset, this.y + noiseOffset, BACTERIUM_SIZE_WIDTH * pulse, BACTERIUM_SIZE_HEIGHT * pulse, 0, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.strokeStyle = '#00f';
                    ctx.lineWidth = 0.5;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * 2 * Math.PI;
                        ctx.beginPath();
                        ctx.moveTo(this.x + Math.cos(angle) * BACTERIUM_SIZE_WIDTH * pulse, this.y + Math.sin(angle) * BACTERIUM_SIZE_HEIGHT * pulse);
                        ctx.lineTo(this.x + Math.cos(angle) * (BACTERIUM_SIZE_WIDTH * pulse + 1), this.y + Math.sin(angle) * (BACTERIUM_SIZE_HEIGHT * pulse + 1));
                        ctx.stroke();
                    }
                } catch (e) {
                    console.error(`Ошибка в Bacterium.draw: ${e.message}`);
                    addConsoleMessage("Ошибка при отрисовке бактерии");
                }
            }
        }

        function addConsoleMessage(message) {
            try {
                const now = new Date();
                const hhmmss = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;
                consoleMessages.push(`${hhmmss} | ${message}`);
                if (consoleMessages.length > 3) {
                    consoleMessages.shift();
                }
                consoleDiv.innerHTML = consoleMessages.join('<br>');
            } catch (e) {
                console.error(`Ошибка в addConsoleMessage: ${e.message}`);
            }
        }

        function initSimulation() {
            try {
                organisms = [];
                eggs = [];
                foodParticles = [];
                corpses = [];
                bacteria = [];
                barriers = [];
                organisms.push(new Organism(Math.random() * WIDTH, Math.random() * HEIGHT, 50, 5, 'green'));
                addConsoleMessage("Симуляция начата");
            } catch (e) {
                console.error(`Ошибка в initSimulation: ${e.message}`);
                addConsoleMessage("Ошибка при инициализации симуляции");
            }
        }

        function checkCollisions() {
            try {
                for (let i = organisms.length - 1; i >= 0; i--) {
                    const org = organisms[i];
                    if (!org || org.isDead) continue;
                    const head = org.segments[0];
                    for (let j = foodParticles.length - 1; j >= 0; j--) {
                        if (!foodParticles[j]) continue;
                        const food = foodParticles[j];
                        const dist = Math.hypot(head.x - food.x, head.y - food.y);
                        if (dist < COLLISION_DIST) {
                            org.eatFood(j);
                        }
                    }
                    for (let j = corpses.length - 1; j >= 0; j--) {
                        if (!corpses[j]) continue;
                        const corpse = corpses[j];
                        const dist = Math.hypot(head.x - corpse.x, head.y - corpse.y);
                        if (dist < COLLISION_DIST) {
                            org.eatCorpse(j);
                        }
                    }
                    for (let j = bacteria.length - 1; j >= 0; j--) {
                        if (!bacteria[j]) continue;
                        const bacterium = bacteria[j];
                        const dist = Math.hypot(head.x - bacterium.x, head.y - bacterium.y);
                        if (dist < COLLISION_DIST) {
                            org.eatBacterium(j);
                        }
                    }
                    if (isCannibalismMode) {
                        for (let j = organisms.length - 1; j >= 0; j--) {
                            if (!organisms[j] || organisms[j].isDead || !organisms[j].infected || organisms[j] === org) continue;
                            const other = organisms[j];
                            const otherHead = other.segments[0];
                            const dist = Math.hypot(head.x - otherHead.x, head.y - otherHead.y);
                            if (dist < COLLISION_DIST) {
                                org.eatOrganism(other);
                                organisms.splice(j, 1);
                            }
                        }
                    } else if (org.type === 'green' && org.energy > 75) {
                        for (let j = organisms.length - 1; j >= 0; j--) {
                            if (!organisms[j] || organisms[j].isDead || organisms[j].type !== 'red') continue;
                            const other = organisms[j];
                            const otherHead = other.segments[0];
                            const dist = Math.hypot(head.x - otherHead.x, head.y - otherHead.y);
                            if (dist < COLLISION_DIST) {
                                org.eatOrganism(other);
                                organisms.splice(j, 1);
                            }
                        }
                    } else if (org.type === 'red') {
                        for (let j = organisms.length - 1; j >= 0; j--) {
                            if (!organisms[j] || organisms[j].isDead || organisms[j].type !== 'green' || organisms[j].energy >= org.energy) continue;
                            const other = organisms[j];
                            const otherHead = other.segments[0];
                            const dist = Math.hypot(head.x - otherHead.x, head.y - otherHead.y);
                            if (dist < COLLISION_DIST) {
                                org.eatOrganism(other);
                                organisms.splice(j, 1);
                            }
                        }
                    }
                }
            } catch (e) {
                console.error(`Ошибка в checkCollisions: ${e.message}`);
                addConsoleMessage("Ошибка при проверке столкновений");
            }
        }

        function updateSimulation() {
            try {
                frameCount++;
                // Count infected organisms
                infectedCount = organisms.filter(org => org && org.infected).length;

                // Toggle cannibalism mode
                if (infectedCount >= CANNIBALISM_THRESHOLD && !isCannibalismMode) {
                    isCannibalismMode = true;
                    addConsoleMessage("Режим каннибализма активирован");
                } else if (infectedCount === 0 && isCannibalismMode) {
                    isCannibalismMode = false;
                    addConsoleMessage("Режим каннибализма завершен");
                }

                // Spawn bacteria only if not in cannibalism mode
                if (!isCannibalismMode && frameCount % BACTERIUM_SPAWN_INTERVAL === 0) {
                    bacteria.push(new Bacterium(Math.random() * WIDTH, Math.random() * HEIGHT));
                    addConsoleMessage("Бактерия появилась");
                }

                organisms = organisms.filter(org => {
                    try {
                        return org && !org.isDead && org.update();
                    } catch (e) {
                        console.error(`Ошибка при фильтрации organisms: ${e.message}`);
                        addConsoleMessage("Ошибка при фильтрации организмов");
                        return false;
                    }
                });

                eggs = eggs.filter(egg => {
                    try {
                        return egg && egg.update();
                    } catch (e) {
                        console.error(`Ошибка при фильтрации eggs: ${e.message}`);
                        addConsoleMessage("Ошибка при фильтрации яиц");
                        return false;
                    }
                });

                bacteria = bacteria.filter(bacterium => {
                    try {
                        return bacterium && bacterium.update();
                    } catch (e) {
                        console.error(`Ошибка при фильтрации bacteria: ${e.message}`);
                        addConsoleMessage("Ошибка при фильтрации бактерий");
                        return false;
                    }
                });

                checkCollisions();
            } catch (e) {
                console.error(`Ошибка в updateSimulation: ${e.message}`);
                addConsoleMessage("Ошибка в обновлении симуляции");
                isRunning = false;
            }
        }

        function drawSimulation() {
            try {
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                foodParticles.forEach(food => food && food.draw());
                barriers.forEach(barrier => barrier && barrier.draw());
                corpses.forEach(corpse => corpse && corpse.draw());
                eggs.forEach(egg => egg && egg.draw());
                organisms.forEach(org => org && !org.isDead && org.draw());
                bacteria.forEach(bacterium => bacterium && bacterium.draw());
            } catch (e) {
                console.error(`Ошибка в drawSimulation: ${e.message}`);
                addConsoleMessage("Ошибка при отрисовке симуляции");
                isRunning = false;
            }
        }

        function gameLoop() {
            if (!isRunning) {
                console.error("Симуляция остановлена из-за ошибки");
                addConsoleMessage("Симуляция остановлена");
                return;
            }
            try {
                updateSimulation();
                drawSimulation();
                requestAnimationFrame(gameLoop);
            } catch (e) {
                console.error(`Ошибка в gameLoop: ${e.message}`);
                addConsoleMessage("Ошибка в игровом цикле");
                isRunning = false;
            }
        }

        function getPosition(event) {
            try {
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;
                if (event && event.touches && event.touches.length > 0) {
                    clientX = event.touches[0].clientX;
                    clientY = event.touches[0].clientY;
                } else if (event && event.clientX !== undefined) {
                    clientX = event.clientX;
                    clientY = event.clientY;
                } else {
                    throw new Error("Некорректное событие");
                }
                const x = (clientX - rect.left) / rect.width * WIDTH;
                const y = (clientY - rect.top) / rect.height * HEIGHT;
                return { x, y };
            } catch (e) {
                console.error(`Ошибка в getPosition: ${e.message}`);
                addConsoleMessage("Ошибка при получении позиции");
                return { x: 0, y: 0 };
            }
        }

        function addParticle(x, y) {
            try {
                if (drawMode === 'food') {
                    foodParticles.push(new FoodParticle(x, y));
                    addConsoleMessage("Еда добавлена");
                } else {
                    barriers.push(new Barrier(x, y));
                    addConsoleMessage("Заграждение добавлено");
                }
            } catch (e) {
                console.error(`Ошибка в addParticle: ${e.message}`);
                addConsoleMessage("Ошибка при добавлении частицы");
            }
        }

        function addLine(x1, y1, x2, y2) {
            try {
                const dist = Math.hypot(x2 - x1, y2 - y1);
                if (dist < MIN_FOOD_SPACING) return;
                const steps = Math.ceil(dist / MIN_FOOD_SPACING);
                for (let i = 1; i < steps; i++) {
                    const frac = i / steps;
                    const px = x1 + (x2 - x1) * frac;
                    const py = y1 + (y2 - y1) * frac;
                    addParticle(px, py);
                }
            } catch (e) {
                console.error(`Ошибка в addLine: ${e.message}`);
                addConsoleMessage("Ошибка при добавлении линии");
            }
        }

        // Mouse events
        canvas.addEventListener('mousedown', (e) => {
            try {
                isDrawing = true;
                const pos = getPosition(e);
                addParticle(pos.x, pos.y);
                lastFoodX = pos.x;
                lastFoodY = pos.y;
            } catch (e) {
                console.error(`Ошибка в mousedown: ${e.message}`);
                addConsoleMessage("Ошибка при добавлении");
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            try {
                if (!isDrawing) return;
                const pos = getPosition(e);
                const dist = Math.hypot(pos.x - lastFoodX, pos.y - lastFoodY);
                if (dist < MIN_FOOD_SPACING) return;
                addLine(lastFoodX, lastFoodY, pos.x, pos.y);
                addParticle(pos.x, pos.y);
                lastFoodX = pos.x;
                lastFoodY = pos.y;
            } catch (e) {
                console.error(`Ошибка в mousemove: ${e.message}`);
                addConsoleMessage("Ошибка при движении мыши");
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
        });

        // Touch events
        canvas.addEventListener('touchstart', (e) => {
            try {
                e.preventDefault();
                isDrawing = true;
                const pos = getPosition(e);
                addParticle(pos.x, pos.y);
                lastFoodX = pos.x;
                lastFoodY = pos.y;
            } catch (e) {
                console.error(`Ошибка в touchstart: ${e.message}`);
                addConsoleMessage("Ошибка при касании");
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            try {
                e.preventDefault();
                if (!isDrawing) return;
                const pos = getPosition(e);
                const dist = Math.hypot(pos.x - lastFoodX, pos.y - lastFoodY);
                if (dist < MIN_FOOD_SPACING) return;
                addLine(lastFoodX, lastFoodY, pos.x, pos.y);
                addParticle(pos.x, pos.y);
                lastFoodX = pos.x;
                lastFoodY = pos.y;
            } catch (e) {
                console.error(`Ошибка в touchmove: ${e.message}`);
                addConsoleMessage("Ошибка при движении касания");
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDrawing = false;
        });

        initSimulation();
        gameLoop();
    </script>
</body>
</html>